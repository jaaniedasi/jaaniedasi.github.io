<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hack The Box - Sau | rogue code revelations</title>
    <link rel="stylesheet" type="text/css" href="../css/main.css">
</head>
<body>
    <div class="post">
        <h1>Hack The Box - Sau</h1>
        <span class="date">February 21, 2024</span>
        <hr />
	    <p>You’re given an IP address to explore, so let’s start with a port scan. Ports 22 and 55555 were open, with the latter piquing my interest. Upon navigating there, I discovered it’s an instance of <a href="https://github.com/darklynx/request-baskets">request-baskets</a>. As I clicked around and skimmed through the Github documentation, it became apparent that it’s a service designed to capture and respond to requests, akin to a mock service. This suggested the CTF aims to simulate stumbling upon a publicly available testing or development service.</p>
	    <p>After familiarizing myself with the application, I began asking the usual question: what holds value in this context? On the application layer, gaining access to other people’s accounts seemed significant due to potential leaks of Personally Identifiable Information (PII) and other sensitive data.</p>
	    <h2 id="xss">XSS</h2>
	    <p>Despite the <a href="https://github.com/darklynx/request-baskets?tab=readme-ov-file#usage">README</a> claiming otherwise, the application stores the authentication token in the browser’s local storage. This setup hinted that testing for Cross-Site Scripting (XSS) vulnerabilities could yield fruitful results. Moreover, examining the Javascript source code revealed HTML entity transformations in place. As many hackers have noted, analyzing security measures often sheds light on the primary concerns of the developer or organization.</p>
	    <p>Further exploration using the browser’s debugger unveiled places where user input was reflected by updating the Document Object Model (DOM) with data from API requests. Notably, the path, headers, query, and body of each request received and stored in the ‘basket’ are reflected on the management interface, with all except the method being processed by the <code>escapeHTML()</code> function. <a href="https://github.com/darklynx/request-baskets/blob/master/web_basket.html.go#L99"><code>escapeHTML()</code></a> transforms the necessary injection elements <code>&lt;&gt;</code> into HTML entities, thus rendering XSS attempts most likely impossible in this context.</p>
	    <p>Since the characters of the HTTP method were not transformed into HTML entities, I also explored potential XSS possibilities there. However, various payloads like <code>GET&lt;&gt;</code> and <code>GET%3C%3E</code>, as well as manipulations with headers (<code>X-HTTP-Method-Override</code>) and HTTP body (<code>_method=GET</code>, <code>method=GET</code>. <code>{"method":"GET"}</code>), failed to produce any meaningful results: either the payload caused some internal server errors or it was ignored all together.</p> <p>Continuing my investigation, I discovered the ability to alter my bucket’s responses. User input in this ‘Basket Responses’ menu utilizes JQuery’s <code>.append()</code> and <code>.val()</code> methods. Any appended input is properly escaped, and <code>.val()</code> merely updates the properties of the in-memory DOM object. Also, even if any vulnerabilities were present, exploiting them would likely entail complex self-XSS techniques.</p>
	    <p>However, it was possible to inject ‘malicious’ Javascript into my bucket’s responses. For instance, adding <code>alert(JSON.stringify(localStorage))</code> to my bucket’s response could easily retrieve tokens, as the content is not confined within a sandbox domain.. For enhanced security, <a href="https://bughunters.google.com/learn/invalid-reports/web-platform/xss/6619189462433792/xss-in-sandbox-domains">isolating user-uploaded HTML and Javascript</a> would be advisable.</p>
	    <h2 id="server-side-vulnerabilities">Server-side vulnerabilities</h2>
	    <p>Given the nature of Hack The Box challenges, uncovering bugs that enable unexpected server-side actions is often needed for the solution. While exploring the aforementioned ‘Basket Responses’ menu, I noticed a tickbox labeled ‘Process body as HTML template.’ This feature intrigued me, prompting a deeper dive into the <a href="https://github.com/darklynx/request-baskets/blob/master/handlers.go#L492">code</a>, which revealed that user input is fed into Go’s <code>html/template</code> engine. This raised the possibility of exploiting the template engine to reveal secrets, potentially by including files from the underlying OS or executing remote code.</p>
	    <p>However, after thoroughly reviewing the documentation and searching online, it became clear that executing such exploits would be unlikely unless the data given to the template had <a href="https://www.onsecurity.io/blog/go-ssti-method-research/">attributes that could interact with the operating system</a>. The data provided to my template is just a map of strings from the query part of the URL and does not seem to have functions to interact with the OS: <a href="https://pkg.go.dev/net/url#Values">https://pkg.go.dev/net/url#Values</a>.</p>
	    <p>I also asked around and a kind user named ‘banane’ hinted that maybe somewhere there’s code that defines custom <a href="https://pkg.go.dev/html/template#Template.Funcs" title="https://pkg.go.dev/html/template#Template.Funcs">Template.Funcs</a> which access the filesystem or run shell commands. But sadly grepping through the source code for the <code>Funcs</code> keyword yielded nothing.</p>
	    <h2 id="the-happy-path-so-to-speak">The happy path, so to speak</h3>
	    <p>The software also offered functionality to proxy requests arriving at my bucket to somewhere else, wherein the software initiates new HTTP requests to configured IP/URL destinations. This behavior hinted at Server-Side Request Forgery. My suspicions were confirmed upon reviewing related <a href="https://github.com/darklynx/request-baskets/issues/91">Github issues</a>. Although I attempted to exploit this by infiltrating files using schemes like <code>file</code>, <code>gopher</code>, and <code>ftp</code>, the underlying <code>net/url</code> Go packages restricted the schema to <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;l=531;drc=b9a08f159d3074ad5921a9d8625b267b64d957bc?q=%22unsupported%20protocol%20scheme%22&amp;ss=go%2Fgo"><code>http</code> or <code>https</code></a>. Despite investigating potential misuse of the parsing mechanism (basically a loop over a string until you encounter a colon), no viable attack vectors came to my mind.</p>
	    <p>After writing and running a rather simple Python script to do a sort of a port scan, I discovered an open port on <code>localhost:80</code>, leading to another open-source software called <a href="https://github.com/stamparm/maltrail/tree/master">maltrails</a>. An intrusion detection system, I guess.</p>
	    <p>From here, I could have continued my testing in various ways. For instance, trying default login credentials, so that I could get access to even more internal information and attack surface as well as possibly cover my tracks. But like the hacker <a href="https://twitter.com/zseano">zseano</a> says: <em>the trend is your friend</em>. Meaning, if there’s one unpatched service, there’s probably more.</p>
	    <p>So, rather than looking around on my own, I turned to Google to look for security vulnerabilities related to <code>maltrail</code>. Among the first results I found a Remote Code Execution flaw, documented in detail <a href="https://github.com/spookier/Maltrail-v0.53-Exploit">here</a>. A comprehensive report is already available <a href="https://huntr.com/bounties/be3c5204-fbd9-448d-b97c-96a8d2941e87/">here</a>, so I won’t delve into specifics. Essentially, the value of the parameter <code>username</code> is used in string interpolation and the resulting string is subsequently given as input to Python’s <code>subprocess.check_output</code>, allowing for arbitrary shell command execution. An injection would resemble something like this: <code>;`command`</code>. Exploiting this vulnerability opens various avenues of attack, including information infiltration, reverse shell spawning, and adding unauthorized <code>ssh</code> keys. Personally, I opted to add my <code>ssh</code> key for easier machine access for later exploitation.</p>
	    <h2 id="linux-privilege-escalation">Linux privilege escalation</h2>
	    <p>Right, now comes the part I suck at the most. So let’s just cut to the chase: I did not manage to solve this part on my own, but it was fun to see how a seemingly innocent <code>sudo systemctl status</code> command could implicitly give a user root privileges! This is nicely summed up in the <a href="https://gtfobins.github.io/gtfobins/systemctl/">GTFOBins repo</a>:
	    <blockquote>
	    <p><i>This invokes the default pager, which is likely to be <code>less</code>, other functions may apply.</i></p>
	    <p><i><code>sudo systemctl</code></i></p>
	    <p><i><code>!sh</code></i></p>
	    </blockquote>
	    </p>
	    <p>That’s about it. All-in-all, a good box!</p>
	    <p>Later!</p>
    </div>
    <footer>
        <a href="/">[Back to index]</a>
    </footer>
</body>
</html>

